/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stack.and.queue;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

class AppTest {

  @Test
  void successfullyPushOntoAStack() throws Exception {
    Stack stack = new Stack();
    stack.push("A");
    assertEquals("A", stack.peek(), "The Top Node data should be returned if a New Node Added Successfully");
  }

  @Test
  void successfullyPushMultipleValuesOntoAStack() throws Exception {
    Stack stack = new Stack();
    stack.push("A");
    stack.push("B");
    stack.push("C");
    assertEquals("C", stack.peek(), "The Top Node data should be returned if  New Multiple Nodes Added Successfully");
  }

  @Test
  void successfullyPopOfTheStack() throws Exception {
    Stack stack = new Stack();
    stack.push("A");
    stack.push("B");
    stack.push("C");
    assertEquals("C", stack.pop(), "The Top Node data should be returned if deleted Successfully");
  }

  @Test
  void MakeStackEmpty() throws Exception {
    Stack stack = new Stack();
    stack.push("A");
    stack.push("B");
    stack.push("C");
    stack.pop();
    stack.pop();
    stack.pop();
    assertEquals("Stack Is Empty", stack.pop(), "Should return (Stack Is Empty) if the stack is empty");
  }

  @Test
  void successfullyPeekNextItemIStack() throws Exception {
    try {
      Stack stack = new Stack();
      stack.push("A");
      stack.push("B");
      stack.push("C");
      assertEquals("B", stack.peekNext(), "The Node Data after Top Node should be returned");
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  @Test
  void successfullyInstantiateAnEmptyStack() {
    Stack stack = new Stack();
    assertEquals(true, stack.isEmpty(), "Should return true if the stack is successfully Instantiated");
  }

  @Test
  public void popOrPeekOnEmptyStackRaisesException() {
    assertThrows(Exception.class, new Executable() {

      @Override
      public void execute() throws Throwable {
        Stack stack = new Stack();
        stack.push("A");
        stack.push("B");
        stack.push("C");
        stack.pop();
        stack.pop();
        stack.pop();
        assertEquals("C", stack.pop(), "Exception thrown when trying to pop from empty stack");
        assertEquals("C", stack.peek(), "Exception thrown when trying to peek from empty stack");
      }
    });
  }

  @Test
  void successfullyEnqueueIntoAQueue() throws Exception {
    try {
      Queue queue = new Queue();
      queue.enqueue("A");
      assertEquals("A", queue.peek(), "Should return the value of the node added to empty Queue");
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  @Test
  void successfullyEnqueueMultipleValuesIntoAQueue() throws Exception {
    try {
      Queue queue = new Queue();
      queue.enqueue("A");
      queue.enqueue("B");
      queue.enqueue("C");
      queue.enqueue("D");
      assertEquals("A", queue.peek(), "Should return the value of the multiple nodes added to empty Queue");
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  @Test
  void successfullyDequeueFromAQueue() throws Exception {
    try {
      Queue queue = new Queue();
      queue.enqueue("A");
      queue.enqueue("B");
      queue.enqueue("C");
      queue.enqueue("D");
      assertEquals("A", queue.dequeue(), "Should return the value of deleted node");
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  @Test
  void successfullyPeekToAQueue() throws Exception {
    try {
      Queue queue = new Queue();
      queue.enqueue("A");
      queue.enqueue("B");
      queue.enqueue("C");
      queue.enqueue("D");
      assertEquals("A", queue.peek(), "Should return the value of front node");
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }

  @Test
  void successfullyEmptyAQueueAfterMultipleDequeues() {
    assertThrows(Exception.class, new Executable() {

      @Override
      public void execute() throws Throwable {
        Queue queue = new Queue();
        queue.enqueue("A");
        queue.enqueue("B");
        queue.enqueue("C");
        queue.enqueue("D");
        queue.dequeue();
        queue.dequeue();
        queue.dequeue();
        queue.dequeue();
        assertEquals("The Queue Is Empty", queue.dequeue(), "Should return the value of front node");
      }
    });
  }

  @Test
  void successfullyInstantiateAnEmptyQueue() {
    Queue queue = new Queue();
    assertEquals(true, queue.isEmpty(), "Should return true if the queue is successfully Instantiated");
  }

  @Test
  public void dequeueOrPeekOnEmptyQueueRaisesException() {

    assertThrows(Exception.class, new Executable() {

      @Override
      public void execute() throws Throwable {
        Queue queue = new Queue();
        assertEquals("C", queue.dequeue(), "Exception thrown when trying to pop from empty stack");
        assertEquals("C", queue.peek(), "Exception thrown when trying to peek from empty stack");
      }
    });
  }
  //======================Code Challenge 11 =====================================
  @Test
  public void pseudoQueueSuccess() throws Exception {
    PseudoQueue pseudoQueue = new PseudoQueue();
    pseudoQueue.enqueue("A");
    pseudoQueue.enqueue("B");
    pseudoQueue.enqueue("C");
    pseudoQueue.enqueue("D");
    assertEquals("A", pseudoQueue.dequeue(), "Should return (Data of deleted node ->(A): FIFO)");
  }

}


