/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package linked.list;

import org.junit.jupiter.api.Test;

import java.util.function.Supplier;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {

  @Test
  void successfullyInstantiate(){
    LinkedList linkedList = new LinkedList();
    assertNull(linkedList.getHead() , "The Linked List should be empty");
  }
  @Test
  void insert(){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    assertTrue(linkedList.includes("H") , "Insertion Fiald");
  }
  @Test
  void isHeadCorrect(){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    linkedList.insert("G");
    linkedList.insert("S");
    linkedList.insert("F");
    assertEquals(linkedList.getHead().getData() , "F" , "The head is not pointing on First Element");
  }
  @Test
  void insertMultipleNodes (){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    linkedList.insert("G");
    linkedList.insert("S");
    linkedList.insert("F");
    assertTrue(linkedList.includes("F"), "There is something wrong With Multiple Nodes Insertion");
    assertTrue(linkedList.includes("S"), "There is something wrong With Multiple Nodes Insertion");
    assertTrue(linkedList.includes("G"), "There is something wrong With Multiple Nodes Insertion");
    assertTrue(linkedList.includes("H"), "There is something wrong With Multiple Nodes Insertion");
  }
  @Test
  void findExistValue(){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    linkedList.insert("G");
    linkedList.insert("S");
    linkedList.insert("F");
    assertTrue(linkedList.includes("F") , "The head is not pointing on First Element");
  }
  @Test
  void findNonExistValue(){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    linkedList.insert("G");
    linkedList.insert("S");
    linkedList.insert("F");
    assertFalse(linkedList.includes("D") , "The head is not pointing on First Element");
  }
  @Test
  void returnAllList (){
    LinkedList linkedList = new LinkedList();
    linkedList.insert("H");
    linkedList.insert("G");
    linkedList.insert("S");
    linkedList.insert("F");
    assertEquals(linkedList.toString() , "{ F } ->{ S } ->{ G } ->{ H } -> null" , "There is something wrong With Multiple Nodes Insertion");

  }
  @Test
  void successfullyAddANodeToTheEnd(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    assertEquals("{ Z } ->{ A } ->{ D } -> null",linkedList.toString(),"The D Char should be in the end of the linked list");

  }

  @Test
  void successfullyAddMultipleNodesToTheEnd (){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    assertEquals("{ Z } ->{ A } ->{ D } ->{ H } -> null",linkedList.toString(),"The method should be able to Add Multiple Nodes end of the linked list");

  }

  @Test
  void insertANodeBefore(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    linkedList.insertBefore("D","R");
    assertEquals("{ Z } ->{ A } ->{ R } ->{ D } ->{ H } ->{ G } -> null",linkedList.toString(),"R char should be added before D char");

  }

  @Test
  void insertANodeBeforeTheFirstNode(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    linkedList.insertBefore("Z","R");
    assertEquals("{ R } ->{ Z } ->{ A } ->{ D } ->{ H } ->{ G } -> null",linkedList.toString(),"R char should be added at the beginning of the linked list ");
  }

  @Test
  void insertANodeAfterTheFirstNode(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    linkedList.insertAfter("Z","R");
    assertEquals("{ Z } ->{ R } ->{ A } ->{ D } ->{ H } ->{ G } -> null",linkedList.toString(),"R char should be after Z char");
  }

  @Test
  void insertANodeAfterTheLastNode(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    linkedList.insertAfter("G","R");
    assertEquals("{ Z } ->{ A } ->{ D } ->{ H } ->{ G } ->{ R } -> null",linkedList.toString(),"R char should be after G char");
  }


  @Test
  void kIsGreaterThanTheLength(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    assertEquals("NO Results",linkedList.kthFromEnd(6),"The number is greater than the size of the list");
  }
  @Test
  void kIsEqualTheSize(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    assertEquals("NO Results",linkedList.kthFromEnd(6),"The number is equal the size of the list");
  }
  @Test
  void kIsNotAPositiveInteger(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    assertEquals("NO Results",linkedList.kthFromEnd(-1),"Negative numbers is not allowed");

  }

  @Test
  void linkedListIsOfASize1(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    assertEquals("Z",linkedList.kthFromEnd(0),"If kth value should be 0 cause the linked list is one node");
  }
  @Test
  void KthIsInTheMiddelOfTheList(){
    LinkedList linkedList = new LinkedList();
    linkedList.append("Z");
    linkedList.append("A");
    linkedList.append("D");
    linkedList.append("H");
    linkedList.append("G");
    assertEquals("D",linkedList.kthFromEnd(2),"kth value should be between 0 and the (size of the linked list -1 )");
  }

  @Test
  void oneOfTheListsEmpty(){
    LinkedList list1=new LinkedList();
    LinkedList list2=new LinkedList();
    list1.append("1");
    list1.append("3");
    list1.append("2");
    list1.append("8");
    list1.append("10");
    list1.append("11");
    list1.append("12");
    list1.append("13");
    LinkedList zip=new LinkedList();
    assertEquals(list1,zip.zipLists(list1,list2),"The second list is empty , it will return the first list");
    LinkedList list3=new LinkedList();
    LinkedList list4=new LinkedList();
    list4.append("1");
    list4.append("3");
    list4.append("2");
    list4.append("8");
    list4.append("10");
    list4.append("11");
    list4.append("12");
    list4.append("13");
    LinkedList zip2=new LinkedList();
    assertEquals(list4,zip2.zipLists(list3,list4),"The first list is empty , it will return the second list");

  }
  @Test
  void bothOfTheListsNotEmpty(){
    LinkedList list1=new LinkedList();
    list1.append("1");
    list1.append("3");
    list1.append("2");
    list1.append("8");
    list1.append("10");
    list1.append("11");
    list1.append("12");
    list1.append("13");
    LinkedList list2=new LinkedList();
    list2.append("5");
    list2.append("9");
    list2.append("4");
    list2.append("6");
    list2.append("7");
    list2.append("10");
    LinkedList zip=new LinkedList();
    assertEquals("{ 1 } ->{ 5 } ->{ 3 } ->{ 9 } ->{ 2 } ->{ 4 } ->{ 8 } ->{ 6 } ->{ 10 } ->{ 7 } ->{ 11 } ->{ 10 } ->{ 12 } ->{ 13 } -> null",zip.zipLists(list1,list2).toString());
  }

}
